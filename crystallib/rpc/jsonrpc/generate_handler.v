module jsonrpc

import freeflowuniverse.crystallib.core.codemodel { Struct }

pub struct HandlerArgs {
pub:
	stateful bool
	receiver Struct
	methods  []codemodel.Function
}

/*
Example handler generated by function looks like:

@[heap]
pub struct PetstoreJsonRpcHandler {
mut:
	petstore Petstore
}

pub fn (mut handler PetstoreJsonRpcHandler)handle(msg string) !string {
	method := jsonrpc.jsonrpcrequest_decode_method(msg)!
	match method {
		'get_pet' {
			return json_rpc_call[string, Pet](msg, handler.petstore.get_pet)!
		}
		else{
			return error('method ${method} not handled')
		}
	}
	return error('this should never happen')
}
*/
//
pub fn generate_handler(args HandlerArgs) ![]codemodel.CodeItem {
	if args.methods.any(it.params.len > 1) {
		return error('multiple method parameters for jsonrpc calls are not supported yet.')
	}

	if args.methods.any(it.params.len == 0
		&& (it.result.typ.symbol == '' && it.result.structure.name == ''))
	{
		return error('cannot generate handler for method without any parameters and return')
	}

	handler_struct := Struct{
		name:   '${args.receiver.name}Handler'
		is_pub: true
		attrs:  [codemodel.Attribute{
			name: 'heap'
		}]
		fields: [
			codemodel.StructField{
				name:      'state'
				structure: args.receiver
			},
		]
	}

	// Handler struct holding state and handle method

	match_stmts := args.methods.map(method_to_call(it))

	body := "mut method := jsonrpc.jsonrpcrequest_decode_method(msg)!
	method = method.trim_string_left('circles.')
	method = texttools.name_fix_pascal_to_snake(method)
	match method {
		${match_stmts.join_lines()}
		else{
			return error('method \${method} not handled')
		}
	}
	return error('this should never happen')" // handler method responsible for handling JSONRPC Request

	handle_method := codemodel.Function{
		name:        'handle'
		description: 'handle handles an incoming JSON-RPC encoded message and returns an encoded response'
		receiver:    codemodel.Param{
			name:    'handler'
			mutable: true
			struct_: handler_struct
		}
		params:      [
			codemodel.Param{
				name: 'msg'
				typ:  codemodel.Type{
					symbol: 'string'
				}
			},
		]
		result:      codemodel.Result{
			typ:    codemodel.Type{
				symbol: 'string'
			}
			result: true
		}
		body:        body
	}
	return [handler_struct, handle_method]
}

fn method_to_call(method codemodel.Function) string {
	mut stmt := "'${method.name}' { "
	if method.params.len == 0 {
		stmt += 'return jsonrpc.invoke[${method.result.typ.symbol}]'
		return '${stmt}(msg, handler.state.${method.name})! }'
	} else if method.result.typ.symbol == '' {
		stmt += 'return jsonrpc.call_void[${method.params[0].typ.symbol}]'
	} else {
		stmt += 'return jsonrpc.call[${method.params[0].typ.symbol}, ${method.result.typ.symbol}]'
	}
	return '${stmt}(msg, handler.state.${method.name})! }'
}
